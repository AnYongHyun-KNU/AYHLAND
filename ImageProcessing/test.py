# -*- coding: utf-8 -*-
# ctrl+4 : 주석처리
"""
Spyder Editor

This is a temporary script file.
"""
for i in range(3): #i가 0부터 3까지 i=3이면 실행안하고 종료  
    print(10)
    print(i)

a=10;
b=10.5;
print(a,b)
a,b=10,30

print(a,b)
#a=input("값을 입력하세요:") #입력값을 문자열로저장함 
print(a)
#a=int(input("정수를 입력하세요:")) #이렇게해야한다.

a=10; b=-2.5; c=1+2j; 
print(a,type(a)),print(b,type(b))

a= False
if (a):
    print("참1")
else:
    print("거짓1") #거짓1이 출력된다.
    
a="hello"
if(a==True): # if(a)로하면 참이지만,  ==하면 hello는 문자열 True가 아니라서 거짓
    print("참2")
else:
    print("거짓2")

#C와 달리 변수형 달라도 같은 숫자라면 연산가능 
num1=18.5
num2=20
print("num1 + num2는",num1+num2,"입니다") #출력이렇게하구나 

# **는 제곱 //는 나눈 몫반환,  %는나머지 반환 
str1= "안녕"
str2= "하세요"
print(str1+str2)

a=True
b=False
print("a and b는",a and b)
print("100==100",100==100)
print("0<20",0<20)
print("100!=200",100!=200)
print('안녕1 \n')
print("안녕2 \n")
print('''작따옴표세개나 "큰따옴표"세개 쓰면, 큰따옴표나 작은따옴표 
      그리고 엔터를 쓸수있다.''')

#문자열과 정수 곱셈은 문자열 반복의미!
str1="문자열*정수"
print(str1*5)

# =============================================================================
# 참고로 공백도 문자열 인덱싱에 포함된다. 
# 마지막요소부터 접근가능 단, 0이아니라 -부터 시작 str[-1]
# str [0] 이런식으로 문자열 한개씩 바꿀수없다. Immutalbe 타입이라서 
# 문자열 슬라이싱 print(list1[0])
# =============================================================================

print("\n문자열인덱싱")
print("str1[0]=",str1[0])
print(str1[0:5],str1[:5],str1[5:]) 

#=============================================================================
# #문자열포맷팅 -> **정수와 변수를 문자열안에 쓱넣는거. **
# 1. str(정수형변수)이용
# 2. %이용  3.프린트이용  4. format이용 (중복가능) => {0}부터임에 주의
# 5. 새로나온 fformat 가장간편 
# =============================================================================

#str= sdasd + asdasd + ' ' 이러는거 print랑 헷갈리지말자. 프린트는 print(a,b,'hi')
print("\n문자열포맷팅")
hour=1; min=35;
time="시간은"+str(hour)+"시"+", 분은"+str(min);
print(time)

city= "newyork"
time="%s의 시간은 %d 분은 %d입니다" %(city,hour,min)
print(time)

print("%s의 시간은 %d 분은 %d입니다" %(city,hour,min))

time=("format이용 시간은 {0} 분은{1}".format(1,2))
print(time)
print("{0}의 시간은 {1}분은 {2}입니다. {2}두번쓰기가능".format(city,hour,min))    
print("{0}의 시간은 {1}분은 {2}입니다. 나이는 {age}.".format("뉴욕",1,35,age=3)) 

print(f"f포맷은 다똑같이하면된 앞에 f만달아주면, \n시간은 {1} 분은 {min+1}")

# =============================================================================
# 문자열함수양식 :  문자열이름.함수이름()
# 리스트랑 문자열함수 헷갈릴 수있지만 문자열은 무 ㅓ많이 안하는듯   
#len() count()  find() replace() split()  
#주의 - 모든 전달 인수에는    a 가아닌 'a' 가들어감 ('문자')
# =============================================================================
print("\n문자열함수")
a="ab c d"
num=a.count(' ')  #count()하면 아무것도 안넣었다고 에러남 
num2=a.find('c') # 그냥 c 하면 에러남. 'c'해야함 + 공백포함해서 세는것 
print(" 공백의 개수, 즉  '문자'의 개수=",num)
print(num2)
print("hello".find('o'))
print("대문자로바꿔서출력", a.upper())

# str [0] 이런식으로 문자열 한개씩 바꿀수없다. Immutalbe 타입이라서
# replace 함수 써야함 
print(a.replace('a','b')) # a자체에 접근해서 바꾸는 건 아님!!. 반환만하는 것. 
print(a.split()) #공백기준으로 쪼개서 리스트로반환 

#len함수 많이씀 
print(len(a))
print(len("asd"))

# =============================================================================
# 리스트  특징: 문자열과 달리 삽입 삭제 변경이 자유로움 
# 리스트가 많이쓰이니 연습할 것  
# =============================================================================
print("\n리스트선인")
#선언
oddnumber =[1,3,5,7,9]
list1=[[1,4,5],1,2,3,'abc']
print(list1)

#인덱싱은 문자열에 했던 것 처럼 []로 한다
print(list1[0])
print('리스트내 리스트 접근 ',list1[0][0])
print('원소간 연산', list1[2]*list1[3])

print("\n리스트슬라이싱")
#슬라이싱
print(oddnumber[1:3]) # 인덱싱처럼 0부터시작. 그러나 0,2만 출력됌. 1:3 -> 1이랑 2
print(oddnumber[1:]) # 참고로 문자열도 인덱싱/슬라이싱 똑같이 가능! 
print(list1[0][1:3]) # 문자열안 인덱싱 후 , 그안에문자열 슬라이싱 

# =============================================================================
# 리스트의 연산. 문자열이랑 걍 똑같다. 행렬떠올리면 안된다.
# =============================================================================
print("\n리스트연산")
even=[2,4,6,8]
odd=[1,3,5,7]
print(even+odd)  #[2, 4, 6, 8, 1, 3, 5, 7]
print(even*2) #[2, 4, 6, 8, 2, 4, 6, 8]

# 문자열은 인덱싱으로 값수정 안되지만 리스트는 가능하다 
even[0]=0
print(even)

# =============================================================================
#핵심)
# 슬라이싱으로 수정하기  -> 무조건 1:1대응  -> 이 의미는 아래를 봐야 이해가된다

# 1개만 넣더라도 슬라이싱으로 넣으면 문자열말고 정수는 단일 값이아닌 [80]이렇게 넣어줘야한다
# 슬라이싱 범위가 [2:6]이고 "hello" 넣으면 차례대로 들어감
# ********** "hello"하나 'h','e'...하나 똑같다. 
# 슬라이싱으로 넣으면 문자열은 위에처럼 들어간다 무조건
# 단, ['big'] 이렇게 넣으니까 big 한단어 자체랑 슬라이싱범위랑 교환됨 
# * 결론: 슬라이싱 범위 = 걍 삭제됌.   이후 우항이 단위따라 입력됨.
# []안에하면 ' '가 글자 문자열 한단위인듯
# 왜냐면 ['b','i','g']='big'='b','i','g'  != ['big'] 였음 
# 슬라이싱 범위가 2:3인데 ['a' ,'b','c']넣으면 2부터 시작해서 abc모두 삽입됨  
# 단, 위의 경우 삭제(대치) 되는 것은  a[2]뿐이다. (즉, 2:3이랑 abc 교환)
# 따라서 a[:]=[1] 하면 모든 원소가 사라지고, 1로 대치됨.  (교환) 
# 슬라이싱 말고 그냥 num[8]=['a','b']하면 우항이 그형태를 유지하며 배열로 8번째원소가댐
# =============================================================================
print("\n리스트삭제")
#리스트 삭제 
even[1]=""
print(even) #[0, '', 6, 8]

even[0:4]=[1,2,3]
print(even) #[1, 2, 3]

even[0:4]='aa'
print(even) # ['a', 'a']

#del : 공간까지 삭제 (객체자체를 삭제)
del even[0] #del even[:3]도가능 
print(even)  #['', 6, 8]첫번째꺼 아예 ''조차 안나옴 

# =============================================================================
# 리스트함수 -> 리스트가 많이쓰이니 연습할 것 
# 주의, 리스트는 문자열 replace와 달리 거의다 그자체가 변하는 거임! 
# append(x), insert(x,y), extend(x(리스트)),remove(x), pop(x) 
# append,extend 맨뒤에 붙이기 ,   insert x위치에 y 삽입 
# remove 가장 처음나오는 x값 삭제 , pop 리스트 마지막요소 반환 후 삭제
# 인자필요없는거 - reverse() : 뒤집음      sort()정렬   a.sort()
# 주의!!! sort(a) 매트랩처럼 아님!!!!  그리고 내림차순은 정렬하고 뒤집기   
# 리스트의 정보알아내기 - index(x) (find같은거)   count(x) x값의개수 반환(문자열과같다
# a.index(3), a.count(3)
# sum(listname) -> 요소합 !
# =============================================================================
print("\n리스트함수")
#appned vs extend .   [1,2,3] 넣으면, append는통째로 하나로인식.extend는쪼개서연결

a=[1,2,3]
a.insert(1,'a') #한번에 하나씩만 추가가능하다. 단 리스트 하나를 넣을 수도 있다. 
print(a) #[1, 'a', 2, 3]

a.extend(['a','b']) #주의 , a 그자체가 변함  
(a) #  [1, 'a', 2, 3, 'a', 'b']

# =============================================================================
# 리스트 심화print개념 : 값 할당
# a= [] 혹은 a= list()형식으로 빈 리스트 생성 = 서랍정 설치랑 물건넣기는 안하고
# 그냥 서랍장 놓을 공간만 넣은거임 . 서랍장 저체가 존재하지 않으므로 서랍장 번호도 없음
# 따라서 저 선언 이후 drawer[0]='양말' 불가능함.
# drawer.append(x), drawer.extend(리스트)는 가능함
# 양말이 들어있는 공간을 먼저 만들어 넣고 넣은 거니까! 
# del쓰면 삭제되는데아예, index는 다른서랍들이 내려와채움. 서랍이공중에 떠있을수 없듯이
# =============================================================================


# =============================================================================
#  딕셔너리 :  자료 인덱스 모르면 찾기 힘드니까 
#  1. 순서가 존재하지 않는다.    2. key:value 형태로 저장 
# 선언1) key/value모두 사용자가 지정할경우 -> 중괄호 
#    딕셔너리 이름 = {key1:value1, key2:value2 }
#    위와같이 할 경우 변수와 키 둘다 ""넣어야하는듯
#    기본적으로 둘다 문자열이라서 그런듯 
#    #첫번째방법이 더 많이 쓰임 
# 선언2) 입력 받는 함수로 초기화
#    딕셔너리 이름 = dict(apple = "사과", bird = "새")
# =============================================================================
print("\n딕셔너리선언")
# 두가지 선언 방법 - 첫번째 방법이 더 많ㅇ ㅣ씅쓰임 
dic1 = {"apple":"사과", "bird":"새", "bug":"벌레"}
# 쌍따옴표맞
dic2 = dict(apple ="사과", bird = "새", bug="벌레")
print(dic1) #{'apple': '사과', 'bird': '새', 'bug': '벌레'}
print(dic2) #{'apple': '사과', 'bird': '새', 'bug': '벌레'}

# =============================================================================
# #딕셔너리는 리스트와 달리 빈딕셔너리를 초기화해도 값 추가할 수 있음
# # 딕셔너리이름[key]=value
# ******** 딕셔너리 각 원소 dic["grape"] 이렇게 접근한다.
#  왜냐면 위에꼐  dic[key] 니까 
#  print(dic["grape") 되더라! 
# =============================================================================
print("\n빈딕셔너리")
#빈 딕셔너리에 값 추가하기 
dic ={}  #선언은 최소한 해줘야함. 선언도 안하고 밑에처럼 하니 안되더라.

#세가지원소추가하기

#dic["apple"]= "사과" 
#위대신 아래처럼 해도된다.
dic = {"apple":"사과"} 
# *****단 이방법은 처음에만가능. 포도랑 바나나 먼저추가하고 사과하면 
# dic은 apple만을 가진 딕셔너리로 남는다!!!!
dic["grape"]= "포도"
dic["fruits"]=["바나나","딸기","오렌지"] # 우항이 한 단위로 저장됌 
print("딕셔너리",dic)

#딕셔너리 삭제 
del dic1["apple"]
print(dic1)

# =============================================================================
# 문자열 요소가 Immutable 이듯 딕셔너리에선 key가그렇다. 
# 1. key는 value를 찾기위한 유일한 값이므로 중복할 수 없음. 
# 2. key에 리스트에는 사용할 수 없습니다.
# 3. value 어떤 값이든 상관 없이 올 수 있다. 
# =============================================================================
print("\n딕셔너리요소")
dic3 = {"num1":1, "num2":2, "num3":3}
#첫번째수정    
# dic3= {"num1"=3} -> 이건 추가하는 건아니다!! 딕셔너리가 새롭게 초기화된다!! 

#두번째수정   (수정이자 ,(빈)딕셔너리에 채워넣는 방법 ) 
dic3["num1"] = 4 
print(dic3)  # 오잉? {'num1': 4}나오고 num2 num3는 출력안되노 
             # -> 해결!  위에서 dic3= {"num1"=3} 이거로 초기화됨.
             # 윗줄제거는 추가가 아님.. 빈덕셔너리에 해서 추가인 줄알앗다. 
print(dic["grape"]) #   *dic["grape"] 이게 딕셔너리 각쌍에 접근하는 방법이다. 


# =============================================================================
# 딕셔너리 함수  -> m 대부분 key를 이용하는 듯 벨류보단 (벨류는 키로 접근가능하니)
#
# dic.keys()  dic.value()  dic.items()   dic.claer() :삭제
#     key/value만 모아 dic)keys([x,y,z...])객체형태로 반환.   
#     item-> key랑value튜플로묶어반환
#     list(dic.keys())하면 리스트형태로 반환. m그러므로 객체형태는 리스트가 아닌듯 
#  dic.get("apple")=dic["apple"]( dic[key] )
#  dic.get("apple", "없습니다") 가능. 없을 경우엔 "없습니다"반환함. 
#  print('cat' in animals)
#  key in dic , key 값이 딕셔너리에 존재하는지 판별
#  print("cat" in animals) 
# =============================================================================
print("\n딕셔너리함수")

dic1 = {"apple":3, "banana":4, "lemon":2}   #자꾸 선언하며 :대신 =쓰는 실수 
print("ㅇㅇ",dic1.keys())   #keys 인데 key해서 계속오류뜸
#위 결과: dict_keys(['apple', 'banana', 'lemon'])

# 뭔진 모르지만 어쨋든 배열이아니라 객체형태로나옴

#리스트로변환

print('dic1_keys_list1 =',list(dic1.keys()))
# list(dic1.keys()) 하니 알수없는 에러뜸

#튜플로 출력하기 
print(dic1.items())  # dict_items([('apple', 3), ('banana', 4), ('lemon', 2)])

# =============================================================================
# 변하지 않는 튜플   
#튜플은 값을 수정할 수 없는 것과 선언방법을 제외하고 리스트와 거의 유사
# 리스트의 기능 모두 재현해줌  
#주의 ) 튜플 요소가 Mutable하면 수정할 수 있다.
# =============================================================================
print("\n변하지 않는 튜플")
T1 = ('a','b','b',1,2,3)
print(T1)
T2 = ("hello",) #하나의 값이면 뒤에 콤마 입력해야한다.
T3 =  "goorm",'b',1,2,3 #괄호 생략해도 튜플! 
print(T3)
T4 = ([1,2,3],{"사과":"apple","포도":"grape"},('a,','b','c'))
print(T4)

#중요 ) 튜플 요소가 Mutable하면 수정할 수 있다.
T4[0][2]=1
print(T4) #([1, 2, 1], {'사과': 'apple', '포도': 'grape'}, ('a,', 'b', 'c'))

T4[1]["사과"]="hi"
print(T4) #([1, 2, 1], {'사과': 'hi', '포도': 'grape'}, ('a,', 'b', 'c'))

#리스트와 동일하게 덧셈 슬라이싱 인덱싱 등 다 지원함
print(T1[0:2]) #('a', 'b')
print(T1+T4) #('a', 'b', 'b', 1, 2, 3, [1, 2, 1], {'사과': 'hi', '포도': 'grape'}, ('a,', 'b', 'c'))

t=13,6,3
print(t.index(3),t.count(3)) #2 1

# =============================================================================
# '*중복*과 순서가 없는' 집합  (set)
# 중괄호 {}를 이용해 선언 및 초기화
# 함수도있음. set() -> 이 함수의 전달인자를 집합으로 만들어주세요  
# set() 특징 1. 요소의 순서가 없다. 2. 중복되는 값은 하나만 저장한다 
# 3. 딕셔너리는 key만 저장한다. (my) .value아님!! )
# 리스트와 튜플 등에 속한 원소 중 중복을 제거하는데에 많이쓰인다. 
# 순서가 없어 인덱싱 이나 슬라이싱 불가능하며 원하면 다시 리스트 등으로 바꿔야함 
# newlist=list(s1), newtuple=tuple(s1) 이렇게! 
# 교집합 합집합 차집합 함수
# s1&s2 또는 s1.intersection(s2),  s1|s2 또는 s1.union(s2)
# 차집함 s1-s2, s1.difference(s2)
# s1.add(a) : 한개추가,  s1.update([a,b,c]) :여러개 추가 . s1.remove(a)한개제거 
# 주의 . s1.update("zyx")는 z, y, x가 추가됨 s1.add("zyx")는 zyx라는 문자열하나추가
# =============================================================================

s1 = {1,2,3,4}
print(s1,type(s1)) # {1, 2, 3, 4} <class 'set'>

#기초 사용 
s = "hello"
s2=set(s)
print(s2,type(s2)) # {'e', 'h', 'l', 'o'} <class 'set'>
                   # 중복이 제거됐다!.

#딕셔너리는 키만 저장한다. 
dic={"s1":"집합","s2":"집합2"}
s3=set(dic)
print(s3,type(s3)) #{'s2', 's1'} <class 'set'>

s1= set([1,2,3,4])
s2= set([1,2,3])
print(s1-s2) #{4}
print(s1.intersection(s2)) #{1, 2, 3}

s1.update([5,6]) #{1, 2, 3, 4, 5, 6}
print(s1)

# =============================================================================
# 반복문
# 파이썬에서 for문 : 초기식 조건식 조건변화식을 한번에 묶여 직관적이고
#자료에 바로 접근할 수 있는 강력한 기능을 지원한다. 
# for i in range(0,10,1) => for문을 빠져나오면 메모리에서 소멸된다. 
#@@@ for i in range(10) 하면 0부터 9까지임!!! 
# 간격 생략 시 1임  범위의 끝인 10은 반환안함. 즉 0<= i <10
# =============================================================================
i=0
while (i!=3):  # 0 1 2 출력 
    print(i)
    i+=1
# =============================================================================
# for j in range(0,10,1): #for문을 빠져나오면 메모리에서 소멸된다.  
#     print("%d" &j) # 2 4 6 8 출력 ... 에러왜뜨지 
# =============================================================================
# =============================================================================
# 조건문 
# if"": = if 0: 이건 False,   if" ": = if 1:  이건 True
# if [1,2,3] : 리스트가 있으므로 True
    # if [] : 리스트가 없으므로 False
# for i in list : 가능!!!!!!!!!!!!!
# =============================================================================

# =============================================================================
for count in range(20):
    
    if count %2 == 0 :
        
        print("쌩썡이를 하고 줄넘기를 %d회 했습니다." %count)
    else:
        print("못했습니다. %d" %count) # &아니고 %임!
# =============================================================================

print("\n while문의 대표적인 사용 ")
    
ch = True
num =1
while ch :  # 1~19까지 출력 20되면 먼저 False 되니까!  
    print(num)
    num +=1
    if num == 20:
        ch = False
        
# =============================================================================
# money = int(input("얼마 들고올래?:"))    
# if money >= 100 and money <=300:
#     print("적당하다 ")
# else:
#     print("에바다")
# =============================================================================

l = [1,2,3,4,"hello"]
if "hello" in l:
    print("있다")   #있다  출력 
else: 
    print("없다")
if 0 not in l:
    print("0이 없다")  #0이없다 
    
# =============================================================================
#     함수
    #  파이썬은 매개 변수에 자료형 적을필요 없다.
# =============================================================================
#함수정의
def plus(num):
    return num+3

#함수호출
result = plus(2)
print(result) #5출력

# =============================================================================
# def inputnum():
#     a = int(input("첫수 입력하세요:"))
#     b= int(input("둘수 입력하세요:"))
#     return a ,b #, 콤마 빼먹지말기 
# n1,n2 = inputnum() #이렇게초기화한다!!! 
# print(n1,n2)
# =============================================================================

#5개수 입력받아서 합출력하기
#good! 
# =============================================================================
# def sumoffive():
#     sum1 = 0
#     sumlist=[]
#     for i in range(5):
#         a= int(input("%d번째수 입력:" %(i+1)))
#         sumlist.append(a)  
#     sum1= sum(sumlist)##@@@위에 int안하면 에러뜬다!!
#     # input은 문자열로 저장하는거잊지말자 
#     print(sum1)
# 
#sumoffive()   
# =============================================================================        

#함수 입력인자 가변으로 받기 
# 그냥 *t 하면됨. 단 튜플로 저장된다 (몇개받을지 모르니)

def subNums(*t):
    print(t,type(t))
    total=0
    for i in t: # 튜플 각 원소에 접근
        total = total +i
    return total
print("합은",subNums(1,2,3,4))

# 필요에따라 가변 인자와 , 보통 인자 둘다 사용가능
# 예제, sum, mul 중 골라서 연산 
# def calNums(choice,*t)
# if choice =="sum" ....

# def func(**kwarh) -> **두개 쓰면 딕셔너리를 입력으로 받음
# 단, : 대신 = 쓴다 
# 단 입력시, key는 따옴표로 감싸지 않음 ex{사과="apple"}
# key는 문자열 자체를 저장.  value는 변수든 뭐든 다올수있따 
 
def func(*nums,**kwargs):
    print(nums)
    print(kwargs)
num = 10
func(1,3,5,7, apple="사과",a = num, num= 4)
#출력
#(1, 3, 5, 7)
#{'apple': '사과', 'a': 10, 'num': 4}

# 파이썬은 출력도 임력과 마찬가지로 형태나 갯수 지정 필요없다.
#반환 값이 4개인 경우 
# a1,a2,a3,a4 = func() 이런식으로해야함
# (사실  a1= func() 하면 반환값 많아서 자동으로 튜플로만들어줌
# 그러므로 출력을 그냥 튜플이나 리스트로 묶어보자 
#@@ return [sum, sub, mean, div] @@

# =============================================================================
# 지역변수와 전역변수  
# =============================================================================
def plusNum(n):
    
    return n+num #n은 지역변수 
num=3 #전역변수 이거한순간 함수안의 num은 3이된다 
print(plusNum(17))  # 20출력됌 
# 어라 num이 더밑에 있는대도 되구나?
# 젅역변수 : 어디서든 참조할 수 있지만 
#######함수내에서 "전역변수=값" 이렇게 대입은 불가능하다 .
# 전역변수가 마냥 좋은건아니다 메모리 효율이 안좋다  
# 전역변수를 불가피학[ '함수내'에서 수정해야한다면 
# 함수안에서 global num해서 알려주고 밑에서 num=3 하면되는데 비추
